{"pages":[],"posts":[{"title":"CSS规范-BEM","text":"CSS样式规范：BEM格式BEM: Block(块) Element(元素_) Modifier(修饰符)Block（块） 该块名称描述它的目的（“这是什么？”-menu or buttons等）,而不是它的形状或状态 该块不影响其环境，这意味着您不应该设置块的外部几何（边距）或定位 功能独立的页面组件, 可重复使用 Element（元素__） 该元素的名称描述它的目的（”这是什么？”-item or text等）,而不是它的形状或状态 元素全名的结构: blcok-name__element-name.使用双下划线__与块名称分割 元素始终是块的一部分, 而不是另一个元素, 所以元素不能定义层级结构, 不能出现block__elem1__elem2这种写法 Modifier (修饰符_) 该修饰符名称描述其外观或者状态或者行为 修饰符的结构: block-name__elementName_ModifierName or block-name_modifier-name 使用_连接 根据BEM方法，块结构应平整，不需要反映块的嵌套DOM结构 12345678910111213&lt;style&gt; .block {} .block__elem1 {} .block__elem2 {} .block__elem3 {}&lt;/style&gt;&lt;div class=\"block\"&gt; &lt;div class=\"block__elem1\"&gt; &lt;div class=\"block__elem2\"&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=\"block__elem3\"&gt;&lt;/div&gt;&lt;/div&gt; 常见写法: 123456&lt;!-- block, block__item, block_modifier, block__item_modifier --&gt;&lt;ul class=\"menu menu_active\"&gt; &lt;li class=\"menu__item menu__item_active\"&gt;Menu Item1&lt;/li&gt; &lt;li class=\"menu__item\"&gt;Menu Item2&lt;/li&gt; &lt;li class=\"menu__item\"&gt;Menu Item3&lt;/li&gt;&lt;/ul&gt; 外部几何和定位，通过父块设置负责外部几何和定位的样式 12345678910111213&lt;style&gt; .button {} .header__button { margin: ; padding: ; position: ; .... }&lt;style&gt;&lt;header class=\"header\"&gt; &lt;button class=\"button header__button\"&gt;&lt;/button&gt;&lt;/header&gt; 了解更多：https://en.bem.info/methodology/quick-start/","link":"/2019/06/20/CSS规范-BEM/"},{"title":"Kendo UI常见使用问题","text":"I. gridgrid传参读取数据 1234567891011121314151617@(Html.Kendo.Grid(Model) .DataSource(dataSource =&gt; dataSource .Ajax() .PageSize(20) .Read(reaad =&gt; read.Action(&quot;Method&quot;,&quot;ControllerName&quot;).Data(&quot;QueryParams&quot;)) // 下面这种方式适用于val为已知值, 不能动态设置其值 //.Read(reaad =&gt; read.Action(&quot;Method&quot;,&quot;ControllerName&quot;), new {param1: val1, param2: val2}) ))&lt;script type=&quot;text/javascript&quot;&gt; function QueryParams () { return { param1: &quot;val1&quot;, param2: &quot;val2&quot; } }&lt;/script&gt; grid添加行checkbox及序号123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263@(Html.Kendo().Grid(Model) .Name(&quot;GridName&quot;) .Columns(columns =&gt; { columns.Select().Width(30).HtmlAttributes(new { @class = &quot;select-checkbox&quot; }); columns.Template(@&lt;text&gt;&lt;/text&gt;).ClientTemplate(&quot;&lt;span class=&apos;row-number&apos;&gt;&lt;/span&gt;&quot;).Title(&quot;序号&quot;).Width(55); }) .ToolBar(toolbar =&gt; { toolbar.Custom.Text(&quot;删除&quot;).HtmlAttributes(new { @class = &quot;del_btn&quot; }).Url(&quot;javascript:void(0)&quot;); }) .Events(events =&gt; { events.DataBound(&quot;onDataGridBound&quot;); }))&lt;script type=&quot;text/javascript&quot;&gt; // grid 编号 function onDataGridBound() { var $grid = $(&quot;#GridName&quot;).data(&quot;kendoGrid&quot;); if ($grid) { var rows = $grid.items(); //连续编号 $(rows).each(function () { var index = $(this).index() + 1 + ($grid.dataSource.pageSize() * ($grid.dataSource.page() - 1)); var rowLabel = $(this).find(&quot;.row-number&quot;); $(rowLabel).text(index); }); } } // 删除 $(&quot;.del_btn&quot;).click(function () { var $grid = $(&quot;#GridName&quot;).data(&quot;kendoGrid&quot;); var idArr = []; $grid.select.each(function (index, row) { var item = $grid.dataItem(row); if (item) { idArr.push({Id: item.Id}); } }) if (idArr.length &gt; 0) { ComfirmAlert(&quot;是否删除所选数据！&quot;, function () { $.ajax({ url: &apos;@Url.Action(&quot;Method&quot;, &quot;ControllerName&quot;)&apos;, type: &apos;POST&apos;, contentType: &apos;application/json&apos;, data: JSON.stringify(idArr), error: function (err) { }, success: function (data) { MessageAlert(data.message); // 重新加载grid $grid.dataSource.read(); } }) }) } })&lt;/script&gt; grid自定义列模版12345678910111213141516171819202122// setTemplate(data) 用data可以获取整行数据columns.Bound(m =&gt; m.StateStr).Title(&quot;状态&quot;).Width(100).ClientTemplate(&quot;#= setTemplate(data) #&quot;);// svgCircle(Progress) 用具体列名则获取当前列名数据columns.Bound(p =&gt; p.Progress).ClientTemplate(&quot;#= svgCircle(Progress) #&quot;).Width(120);&lt;script type=&quot;text/javascript&quot;&gt; function setTemplate(item){ // item.StateStr item.xxx 这里可以进行计算 return &quot;&apos;&lt;span&gt;&apos;+item.StateStr+&apos;&lt;/span&gt;&quot;; } // gird添加圆环进度条(svg)fromat function svgCircle(val) { var setCircleVal = Math.floor(2 * Math.PI * 15) * (val/100); return &quot;&lt;div style=&apos;text-align: center;&apos;&gt;&quot; + &quot;&lt;div class=&apos;header_circle_text&apos;&gt;&quot; + &quot;&lt;span&gt;&quot; + val + &quot;%&lt;/span&gt;&quot; + &quot;&lt;/div&gt;&quot; + &quot;&lt;svg xmlns=&apos;http://www.w3.org/200/svg&apos; style=&apos;width:50px;height:50px;position:absolute;margin-left:-25px;margin-top:-35px;&apos;&gt;&quot; + &quot;&lt;circle cx=&apos;25&apos; cy=&apos;25&apos; r=&apos;15&apos; fill=&apos;none&apos; stroke=&apos;rgb(233,233,233)&apos; stroke-width=&apos;2&apos; stroke-linecap=&apos;round&apos; /&gt;&quot; + &quot;&lt;circle class=&apos;J_demo3&apos; cx=&apos;25&apos; cy=&apos;25&apos; r=&apos;15&apos; fill=&apos;none&apos; stroke=&apos;rgb(70,128,254)&apos; stroke-width=&apos;2&apos; stroke-dasharray=&apos;&quot; + setCircleVal +&quot;,10000&apos; /&gt;&quot; + &quot;&lt;/svg&gt;&quot; + &quot;&lt;/div&gt;&quot; } 修改grid中的popUp弹窗标题123456789101112131415161718@(Html.Kendo().Grid(Model) .Editable(editable =&gt; { editable.Mode(GridEditMode.PopUp); editable.TemplateName(&quot;_YourEditTemplateName&quot;).Window(m =&gt; { m.Width(980); }); }) .Events(events =&gt; { events.Edit(&quot;eventsOfEdit&quot;); }) )&lt;script type=&quot;text/javascript&quot;&gt; function eventsOfEdit (e) { if (e &amp;&amp; e.model &amp;&amp; e.model.isNew()) { $(&quot;.k-window-title&quot;).text(&quot;your new title, eg: add&quot;; } else { $(&quot;.k-window-title&quot;).text(&quot;your new title, eg: edit&quot;); } }&lt;/script&gt; gird添加toolbar需求: 用户可以搜索查询指定字段的数据.实现: toolbar元素可以通过append方式追加元素 (添加一个按钮，通过js在这个按钮append元素) 或者使用template(不过需要重写按钮的方法,比较麻烦) 123456789101112131415161718192021222324@(Html.Kendo.Grid(Model) .Name(&quot;GridName&quot;) .ToolBar(toolbar =&gt; { toolbar.Custom.Text(&quot;搜索&quot;).HtmlAttribute(new { @class = &quot;search_label&quot; }).Url(&quot;javascript:void(0)&quot;); }))&lt;script type=&quot;text/javascript&quot;&gt; $(document).ready(function () { $(&quot;.search_label&quot;).before(&quot;&lt;input placeholder=&apos;请输入内容&apos; id=&apos;search_keyword&apos; class=&apos;search_keyword&apos; /&gt;&quot;) }) $(&quot;.search_label&quot;).click(function () { var key_word = $(&quot;#search_keyword&quot;).val(); var $grid = $(&quot;#GridName&quot;).data(&quot;kendoGrid&quot;); if ($grid) { $grid.dataSource.filter({ field: &quot;Name&quot;, operator: &quot;contains&quot;, value: keyword }) } })&lt;/script&gt; Ⅱ. TreeView自动选中某个节点1234567891011var treeview = $(\"#Treeview\").data(\"kendoTreeView\");var getitem = treeview.dataSource.get(\"id\"); // id为节点数据的id值if (typeof (getitem) != \"undefined\") { var selectitem = treeview.findByUid(getitem.uid); if (typeof (selectitem) != \"undefined\") { // 使用treeview.select()可获取到当前选中的节点 // 根据一个节点获取它的父级节点treeview.parent(node) treeview.select(selectitem); // 设置选中的节点 treeview.expandTo(treeview.dataItem(selectitem)); // 展开到选中节点 }}","link":"/2019/06/17/KendoUI常见使用问题/"},{"title":"Cordvoa+Vue基础环境搭建","text":"安装Cordova1npm i -g cordova 这里不建议使用cnpm方式安装, 今天通过cnpm安装初始化项目的时候总是失败. 初始化Cordova项目1cordova create projectFileName packageName appName for more info: 官方文档 设置平台(已Android为例)1cordova platfrom add android 搭建Vue项目在cordova项目同级目录创建vue项目, 放在同级目录方便管理 1vue init webpack projectname Vue项目配置12345678910修改 projectname/config/index.jsbuild: { // Template for index.html index: path.resolve(__dirname, '../../www/index.html'), // Paths assetsRoot: path.resolve(__dirname, '../../www'), assetsSubDirectory: './static', assetsPublicPath: './',} Vue项目打包1npm run build 项目打包完成后, 在cordova项目目录中的www文件夹里面会自动生成打包过后的文件 Cordova打包Cordova打包需要Android开发环境, 可参考AndroidStudio环境搭建 1cordova run build 执行命令后, 可能会遇到以下问题: 下载gradle-4.10.3-all(以你的版本为准)失败解决办法：根据提示的下载链接, 手动下载文件并解压, 然后放在(你的AndroidStudio安装文件位置)AndroidStudio/gradle/gradle-4.10.3/解压后的文件 编译失败如图所示:解决办法：这个问题引起的原因是网络的问题, 正常情况下我们是无法访问谷歌的, 所以我们无法获取其资源. 因为我们可以借助相关软件访问谷歌的资源或者修改相关文件. 在 projectFileName/platforms/android/build.gradle, projectFileName/platforms/android/app/build.gradle, projectFileName/platforms/android/CordovaLib/build.gradle 这几个文件中找到所有的 repositories, 修改为(添加maven)： 123456repositories { jcenter() maven { url &quot;http://maven.aliyun.com/nexus/content/groups/public/&quot; }} 打包成功的文件会放在projectFileName/platforms/android/app/build/outputs/apk/debug/app-debug.apk Cordova调试1cordova run android 我们可以通过数据线将手机连接电脑, 实现调试查看效果, 也可通过adb远程调试, 摆脱数据线的束缚. 电脑和手机处于同一局域网, 现将手机通过数据线连接电脑, 打开控制窗口执行: 12adb tcpip 5555adb connect your-Phone-Wifi-Ip:5555 连接成功后会提示 1connected to 192.168.1.xxx:5555 此时就可以拔掉数据线了, 此时就可以通过 1cordova run android 直接调试了. 查看控制台打开谷歌浏览器, 地址栏输入: chrome://inspect/#devices, 在这个界面你可以看到运行的项目, 点击 inspectinspect 或者 fallback 就可以看到控制台了. 其他 在Cordova中不会出现跨域的情况, 因此我们可以直接访问. eg: 我们之前的访问接口为: http://localhost:8080/xxx, 现在就可以直接用http://192.168.1.xx:8080/xxx进行访问. 当我们使用http进行访问的时候, 可能会遇到访问失败的情况, 提示 net::ERR_CLEARTEXT_NOT_PERMITTED, 原因是从Android 6.0开始引入了对Https的推荐支持, 与以往不同, Android P的系统上面默认所有Http的请求都被阻止了.解决办法: 修改 projectFileName/platforms/android/app/src/main/AndroidManifest.xml, 在 &lt;application&gt;&lt;/application&gt; 添加 android:usesCleartextTraffic=&quot;true&quot;, 修改为 1&lt;application android:hardwareAccelerated=\"true\" android:icon=\"@mipmap/ic_launcher\" android:label=\"@string/app_name\" android:supportsRtl=\"true\" android:usesCleartextTraffic=\"true\"&gt;","link":"/2019/09/02/Cordova+Vue基础环境搭建/"},{"title":"MAML-使用贝塞尔曲线绘制水波纹充电动画","text":"MAML官方文档中有一段关于贝塞尔曲线的介绍, 奈何说明文档介绍有限, 只好依葫芦画瓢整了一个水波纹充电动画效果, 代码如下(主题插件格式)： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;Lockscreen version=\"2\" frameRate=\"60\" screenWidth=\"1080\"&gt; &lt;!-- 波长 --&gt; &lt;var name=\"wave_width\" type=\"number\" expression=\"#move_x\" /&gt; &lt;!-- 水波纹位置- 由电量控制 --&gt; &lt;var name=\"wave_y\" type=\"number\" expression=\"(2*valueholder_circle_r+valueholder_wave_height)*(1-#battery_level/100)\" /&gt; &lt;!-- 振幅 --&gt; &lt;ValueHolder name=\"valueholder_wave_height\" type=\"param\" description=\"振幅\" defaultValue=\"50\" /&gt; &lt;!-- 圆半径 --&gt; &lt;ValueHolder name=\"valueholder_circle_r\" type=\"param\" description=\"圆半径\" defaultValue=\"380\" /&gt; &lt;!-- group位置x --&gt; &lt;ValueHolder name=\"valueholder_group_x\" type=\"param\" description=\"x坐标\" defaultValue=\"175\" /&gt; &lt;!-- group位置y --&gt; &lt;ValueHolder name=\"valueholder_group_y\" type=\"param\" description=\"y坐标\" defaultValue=\"#screen_height/2-80\" /&gt; &lt;!-- 水波纹颜色-circle --&gt; &lt;ValueHolder name=\"valueholder_wave_color\" type=\"param\" description=\"水波纹颜色\" defaultValue=\"#ff00ff00\" /&gt; &lt;!-- 圆颜色- --&gt; &lt;ValueHolder name=\"valueholder_circle_color\" type=\"param\" description=\"圆颜色\" defaultValue=\"#ffffffff\" /&gt; &lt;!-- 水波纹颜色-paint 本来这里想使用#ffffffff的格式控制颜色, 没有实验成功--&gt; &lt;ValueHolder name=\"valueholder_paint_wave_color_r\" type=\"param\" description=\"圆颜色(R)\" defaultValue=\"255\" /&gt; &lt;ValueHolder name=\"valueholder_paint_wave_color_g\" type=\"param\" description=\"圆颜色(G)\" defaultValue=\"255\" /&gt; &lt;ValueHolder name=\"valueholder_paint_wave_color_b\" type=\"param\" description=\"圆颜色(B)\" defaultValue=\"255\" /&gt; &lt;!-- 圆透明度- --&gt; &lt;ValueHolder name=\"valueholder_circle_alpha\" type=\"param\" description=\"透明度\" defaultValue=\"125\" /&gt; &lt;!-- 文本颜色- --&gt; &lt;ValueHolder name=\"valueholder_text_color\" type=\"param\" description=\"文本颜色\" defaultValue=\"#fffefefe\" /&gt; &lt;!-- 动画时长 --&gt; &lt;!-- &lt;Var name=\"time_count\" type=\"number\" expression=\"3000\" /&gt; &lt;Var name=\"ani_time\" type=\"number\" expression=\"#move_x\" /&gt; --&gt; &lt;Var name=\"crg_val\" expression=\"ifelse(eq(1, #battery_state)||eq(3, #battery_state), 1, 0)\" /&gt; &lt;Var name=\"crg\" expression=\"#crg_val\" threshold=\"1\"&gt; &lt;Trigger&gt; &lt;Command target=\"move_x.animation\" value=\"play\" delay=\"1000\"/&gt; &lt;/Trigger&gt; &lt;/Var&gt; &lt;Var name=\"move_x\"&gt; &lt;VariableAnimation loop=\"true\" initPause=\"true\"&gt; &lt;Item value=\"#screen_width\" time=\"0\" /&gt; &lt;Item value=\"0\" time=\"1500\" /&gt; &lt;Item value=\"-#screen_width\" time=\"3000\" /&gt; &lt;/VariableAnimation&gt; &lt;/Var&gt; &lt;!-- 先初始化 --&gt; &lt;ExternalCommands&gt; &lt;Trigger action=\"init\"&gt; &lt;!-- scale_mum：CanvasDrawer是独立的，先计算在其它分辨率下的缩放比 --&gt; &lt;VariableCommand name=\"scale_mum\" expression=\"int(#raw_screen_width/1.08)/1000\" /&gt; &lt;!-- 水波纹path --&gt; &lt;MethodCommand targetType=\"ctor\" class=\"android.graphics.Path\" return=\"pathWave\" returnType=\"object\"/&gt; &lt;!-- moveTo --&gt; &lt;MethodCommand target=\"pathWave\" targetType=\"var\" method=\"moveTo\" paramTypes=\"float,float\" params=\"-#move_x,0\"/&gt; &lt;!-- quadTo --&gt; &lt;MethodCommand target=\"pathWave\" targetType=\"var\" method=\"quadTo\" paramTypes=\"float,float,float,float\" params=\"-0.75*#wave_width,valueholder_wave_height,-#wave_width/2,0\"/&gt; &lt;MethodCommand target=\"pathWave\" targetType=\"var\" method=\"quadTo\" paramTypes=\"float,float,float,float\" params=\"-0.25*#wave_width,-valueholder_wave_height,0,0\"/&gt; &lt;MethodCommand target=\"pathWave\" targetType=\"var\" method=\"quadTo\" paramTypes=\"float,float,float,float\" params=\"#wave_width/4,valueholder_wave_height,#wave_width/2,0\"/&gt; &lt;MethodCommand target=\"pathWave\" targetType=\"var\" method=\"quadTo\" paramTypes=\"float,float,float,float\" params=\"0.75*#wave_width,-valueholder_wave_height,#wave_width,0\"/&gt; &lt;MethodCommand target=\"pathWave\" targetType=\"var\" method=\"quadTo\" paramTypes=\"float,float,float,float\" params=\"#wave_width*1.25,valueholder_wave_height,#wave_width*1.5,0\"/&gt; &lt;MethodCommand target=\"pathWave\" targetType=\"var\" method=\"quadTo\" paramTypes=\"float,float,float,float\" params=\"1.75*#wave_width,-valueholder_wave_height,#wave_width*2,0\"/&gt; &lt;!-- lineTo --&gt; &lt;MethodCommand target=\"pathWave\" targetType=\"var\" method=\"lineTo\" paramTypes=\"float,float\" params=\"#wave_width*2,-#wave_y\"/&gt; &lt;MethodCommand target=\"pathWave\" targetType=\"var\" method=\"lineTo\" paramTypes=\"float,float\" params=\"-#wave_width,-#wave_y\"/&gt; &lt;MethodCommand target=\"pathWave\" method=\"close\" /&gt; &lt;!-- 水波纹style --&gt; &lt;MethodCommand targetType=\"ctor\" class=\"android.graphics.Paint\" return=\"paintWave\" returnType=\"object\"/&gt; &lt;MethodCommand targetType=\"var\" class=\"miui.maml.util.ReflectionHelper\" method=\"getEnumConstant\" paramTypes=\"String,String\" params=\"'android.graphics.Paint$Style','FILL'\" return=\"style\" returnType=\"object\"/&gt; &lt;MethodCommand target=\"paintWave\" targetType=\"var\" method=\"setStyle\" paramTypes=\"android.graphics.Paint$Style\" params=\"'style'\"/&gt; &lt;!-- 这里应该使用paint的xfermodel进行资源的剪裁, 依旧实验失败...只好曲线救国了, 通过maml的xfermodel剪裁 --&gt; &lt;/Trigger&gt; &lt;/ExternalCommands&gt; &lt;Group visibility=\"eq(#battery_state,1)||eq(#battery_state,3)\" alignV=\"top\" align=\"left\" x=\"valueholder_group_x+2+#defaultScreen_x\" y=\"valueholder_group_y\" scale=\"#scale_mum\" w=\"valueholder_circle_r*2+4\" h=\"valueholder_circle_r*2+4\" layered=\"true\"&gt; &lt;CanvasDrawer x=\"#move_x\" y=\"#wave_y-valueholder_wave_height\"&gt; &lt;Triggers&gt; &lt;Trigger action=\"draw\"&gt; &lt;MethodCommand target=\"paintWave\" targetType=\"var\" method=\"setARGB\" paramTypes=\"int,int,int,int\" params=\"255,valueholder_paint_wave_color_r,valueholder_paint_wave_color_g,valueholder_paint_wave_color_b\"/&gt; &lt;!-- &lt;MethodCommand target=\"paintWave\" targetType=\"var\" method=\"setColor\" paramTypes=\"String\" params=\"'@'\"/&gt; &lt;MethodCommand target=\"paintWave\" targetType=\"var\" method=\"setColor\" paramTypes=\"int\" params=\"#paint_wave_color_v\"/&gt;--&gt; &lt;MethodCommand target=\"__objCanvas\" targetType=\"var\" method=\"drawPath\" paramTypes=\"android.graphics.Path,android.graphics.Paint\" params=\"'pathWave','paintWave'\"/&gt; &lt;/Trigger&gt; &lt;/Triggers&gt; &lt;/CanvasDrawer&gt; &lt;!-- &lt;Rectangle x=\"2\" y=\"0\" w=\"valueholder_circle_r*2+4\" h=\"#wave_y-2*valueholder_wave_height\" fillColor=\"valueholder_circle_color\"&gt; &lt;/Rectangle&gt; --&gt; &lt;Text x=\"valueholder_circle_r+2-68\" align=\"left\" y=\"valueholder_circle_r*2-100\" size=\"68\" color=\"valueholder_text_color\" textExp=\"#battery_level+'%'\"/&gt; &lt;!-- 充电背景色 --&gt; &lt;Circle alpha=\"valueholder_circle_alpha\" alignV=\"top\" align=\"left\" x=\"valueholder_circle_r+2\" y=\"valueholder_circle_r\" r=\"valueholder_circle_r\" strokeColor=\"valueholder_wave_color\" weight=\"valueholder_circle_r\" cap=\"round\" dash=\"1,1,1,1\" strokeAlign=\"inner\" xfermodeNum=\"10\"&gt; &lt;/Circle&gt; &lt;/Group&gt;&lt;/Lockscreen&gt;","link":"/2019/07/10/MAML-使用贝塞尔曲线绘制水波纹充电动画/"},{"title":"MAML-控制变量在0和1之间切换","text":"实现目标：一个开关按钮, 点击实现文本颜色切换, 解锁后保持状态不变. 以前多在config.xml里面进行主题变量的配置, eg： 123456&lt;Group text=\"锁屏文本颜色\"&gt; &lt;NumberChoice text=\"文本颜色选择\" id=\"color_style\" default=\"0\"&gt; &lt;Item value=\"1\" text=\"白色-适用于深色类壁纸\"/&gt; &lt;Item value=\"0\" text=\"黑色-适用于浅色类壁纸\"/&gt; &lt;/NumberChoice&gt;&lt;/Group&gt; 根据这种写法, 就可以在manifest.xml使用@color_style动态获取到该值. 根据这种写法唯一的缺点就是用户需要打开锁屏自定义设置界面能进行设置, 然鹅大多数用户估计都不知道还有锁屏自定义设置功能存在. 所以现在想在锁屏界面中直接进行变量的控制. 代码如下： 123456789101112131415161718192021222324252627282930313233&lt;!-- 开关关闭状态x坐标 --&gt;&lt;var name=\"circle_x\" expression=\"92\" const=\"true\" /&gt;&lt;Button x=\"32\" y=\"800\" w=\"200\" h=\"100\" algin=\"left\" alignV=\"top\"&gt; &lt;Normal&gt; &lt;!-- 绘制开关 --&gt; &lt;!-- 开关边框 --&gt; &lt;Rectangle name=\"rec\" algin=\"left\" alignV=\"top\" x=\"32\" y=\"800\" w=\"200\" h=\"100\" cornerRadius=\"50,50\" strokeColor=\"#ff1e1e1e\" fillColor=\"#4cffffff\" weight=\"4\" cap=\"round\" dash=\"0\" strokeAlign=\"center\"&gt; &lt;/Rectangle&gt; &lt;!-- 开关关闭状态圆圈 --&gt; &lt;Circle visibility=\"!(#toggle_state)\" name=\"toggle_off\" algin=\"left\" alignV=\"top\" x=\"#circle_x\" y=\"850\" r=\"40\" strokeColor=\"#ffffffff\" fillColor=\"#ff1e1e1e\" weight=\"2\" cap=\"round\" dash=\"0\" strokeAlign=\"center\"&gt; &lt;/Circle&gt; &lt;!-- 开关开启状态圆圈 --&gt; &lt;Circle visibility=\"#toggle_state\" name=\"toggle_on\" algin=\"left\" alignV=\"top\" x=\"#circle_x+70\" y=\"850\" r=\"40\" strokeColor=\"#ffffffff\" fillColor=\"#ffefefef\" weight=\"2\" cap=\"round\" dash=\"0\" strokeAlign=\"center\"&gt; &lt;/Circle&gt; &lt;/Normal&gt; &lt;Triggers&gt; &lt;Trigger action=\"down\"&gt; &lt;!-- 中间变量temp, 此时toggle_state未赋值, 默认为0 --&gt; &lt;VariableCommand name=\"temp\" expression=\"#toggle_state\" persist=\"true\" const=\"true\"/&gt; &lt;!-- 当temp为1时, toggle_state为0 --&gt; &lt;VariableCommand name=\"toggle_state\" expression=\"0\" condition=\"eq(#temp,1)\" persist=\"true\"/&gt; &lt;!-- 当temp为0时, toggle_state为1 --&gt; &lt;VariableCommand name=\"toggle_state\" expression=\"1\" condition=\"eq(#temp,0)\" persist=\"true\"/&gt; &lt;!-- @vr_value 这个值就是我们需要的值 --&gt; &lt;VariableCommand name=\"vr_value\" expression=\"ifelse(#toggle_state,'#ffffffff','#ff000000')\" type=\"string\" const=\"true\" persist=\"true\"/&gt; &lt;/Trigger&gt; &lt;/Triggers&gt;&lt;/Button&gt;&lt;!-- 调试文本, 可删 --&gt;&lt;Text name=\"vrs\" size=\"32\" color=\"#f03326\" x=\"100\" y=\"400\" format=\"vr_value %s\" paras=\"@vr_value\" /&gt;&lt;Text name=\"vdrs\" size=\"32\" color=\"#f03326\" x=\"100\" y=\"500\" format=\"toggle_state %d\" paras=\"#toggle_state\" /&gt;&lt;Text name=\"rs\" size=\"32\" color=\"#f03326\" x=\"100\" y=\"600\" format=\"toggle_off %d\" paras=\"#toggle_off.visibility\" /&gt;&lt;Text name=\"ras\" size=\"32\" color=\"#f03326\" x=\"100\" y=\"700\" format=\"toggle_on %d\" paras=\"#toggle_on.visibility\" /&gt;","link":"/2019/07/09/MAML-控制变量在0和1之间切换/"},{"title":"Markdown Lint","text":"Markdown文档规范运行环境：Visual Studio Code + markdownlink插件以该markdownlink插件为标准, 例举自己编写md文档时出现的不规范行为.新建markdownlint自定义配置文件：.markdownlink.json MD001MD001-Heading levels should only increment by one level at a time(标题级别默认只能逐级增加) MD010MD010-Hard Tabs(默认tab与space不允许混用)修改.markdownlink.json, 添加 123{ \"MD010\": false} MD013MD013-Line length(默认不超过80)修改.markdownlink.json, 添加 123{ \"MD013\": false} MD022MD022-Headings should be surrounded by blank lines(标题前后应换行) 123## TitleSome Text... MD030MD030-Spaces after list markers(列表标记(例如’ -‘，’ *’，’ +’或’ 1.’)与列表项文本之间的空格数, 默认为1) MD031MD031-Fenced code blocks should be surrounded by blank lines(代码部分前后换行) MD033MD033-Inline HTML(默认: 标记时不允许使用原始HTML)修改.markdownlink.json, 添加 123{ \"MD033\": false} MD034MD034-Bare URL used(使用了纯URL, 应使用) eg: for more infomation, see http://ctrlands.com you should use: for more infomation, see &lt;http://ctrlands.com&gt; MD038MD038-Spaces inside code span elements(代码块范围不建议包含空格)eg: 1` some text... ` you should use: 1`some text...` MD047MD047-Files should end with a single newline character(文档结束处空一行)","link":"/2019/06/19/Markdown-Lint/"},{"title":"使用Electron将Vue项目打包为桌面应用-基础篇","text":"一天下午, 我正吹着空调, 带着耳机, 愉快的扮演着代码搬运工, 突然我的组长告诉我, 让我把一个vue项目打包成桌面应用. (ps: 啥, vue项目还能打包成桌面应用, 请自行脑补我的黑人脸问号), 后来组长发给我一条消息: Electron+Vue. 抱着try yi try的态度, 打开了搜索引擎, 跟着相关文档step by step, 哎哟, 不错哦, 还真阔以, 牛beer. 运行一看, 居然还阔以f12, 再一看, 不就是那二锅头兑的那白开水嘛, 不好意思, 拿错剧本了, 不就是一个桌面应用的壳子套个浏览器嘛. 不过还是牛beer. 本着技多不压身(实之吾恐忘之), 特此以文档记之. 使用Electron将Vue项目打包成桌面应用有两种方式(就目前而言, 我就只知道这两种2333), 一种是将vue项目打包扔进Electron项目中, 另外一种就是在Vue项目引入Electron, 然后在Vue中打包为桌面应用. 话不多说, 开整. 本文以第二种方式为例: 先创建一个Electron-Vue项目1vue init simulatedgreg/electron-vue yourprojectname Electron-Vue模板为我们封装好了相关Electron配置, 拿来即用. 然后根据自己需求选择配置, 打包方式我选的’builder’. 模板下载完成后, 进入文件, 下载相关依赖包. 1cnpm install (重要: 不要使用npm, 使用cnpm, 原因: npm: 下载速度=树懒的速度, cnpm: 比npm的速度稍微快一点).因为一些Electron的相关依赖包在墙外, 使用npm有很大几率会下载失败, 当时我不知道, 使用的npm, 结果把我卡在这儿了, 这也下载失败, 那也下载失败, 忍不住想大吼一句ZnVjaw==相关依赖下载完成后, 运行 1npm run dev 就可以看到界面了. 大概就是下图的样子下方就是浏览器中的控制台. 打包Vue项目为桌面应用打包命令为: 1npm run build 执行命令后, 然后就会下载相关Electron的相关依赖包进行打包, 然而就在下载相关依赖包的时候问题就接踵而至了, 由于不可抗力因素原因, 我们无法通过cnpm方式下载相关依赖包, 所以我们需要手动去下载相关依赖包, 然后放在相关文件夹中. 需要的无法下载的相关依赖包我们可以在执行npm run build的时候看到.需要的相关依赖包可能涉及到(以windows为例, 以你所需的Electron为准): electron-v2.0.18-win32-x64.zip 可在这里下载淘宝镜像站, 或在这里下载官方git仓库放在C:\\Users\\username\\ .electron\\electron-v2.0.18-win32-x64.zip(不需解压)同时放在C:\\Users\\username\\AppData\\Local\\electron\\Cache\\electron-v2.0.18-win32-x64.zip(不需解压) 所需文件 nsis-3.0.3.2.7z nsis-resources-3.3.0.7z winCodeSign-2.4.0.7z app-builder-v0.6.1-x64.7z(可能需要) 主路径: C:\\Users\\username\\AppData\\Local\\electron-builder\\Cache\\ C:\\Users\\username\\AppData\\Local\\electron-builder\\Cache\\nsis\\nsis-3.0.3.2.7z(需解压)C:\\Users\\username\\AppData\\Local\\electron-builder\\Cache\\nsis\\nsis-resources-3.3.0.7z(需解压)C:\\Users\\username\\AppData\\Local\\electron-builder\\Cache\\winCodeSign\\winCodeSign-2.4.0.7z(需解压)C:\\Users\\username\\AppData\\Local\\electron-builder\\Cache\\app-builder\\app-builder-v0.6.1-x64.7z(可能需要, 需解压) 文件结构如下: 1234567891011121314151617electron Cache electron-v2.0.18-win32-x64.zip SHASUMS256.txt-2.0.18electron-builder cache app-builder app-builder-v0.6.1-x64 解压app-builder-v0.6.1-x64.7z所得文件 nsis nsis-3.0.3.2 解压nsis-3.0.3.2.7z所得文件 nsis-resources-3.3.0 解压nsis-resources-3.3.0.7z所得文件 winCodeSign winCodeSign-2.4.0 解压winCodeSign-2.4.0.7z所得文件 相关依赖包下载安装完成后, 就等打包, 打包完成后的文件放在项目根目录/dist文件下.图中箭头指示的就是打包完成的桌面应用文件. 其他 跨域问题修改 yourprojectname/.electron-vue/dev-runner.js, 添加一下内容: 12345678910const httpProxyMiddleware = require('http-proxy-middleware')function startRenderer () { return new Promise((resolve, reject) =&gt; { # target为跨域的访问接口地址, eg: 后台接口为: http://localhost:8999/getuser, 在vue中我们使用/getuser即可 server.use(httpProxyMiddleware({ target: 'http://localhost:8999', changeOrigin: true })) })}","link":"/2019/08/30/使用Electron将Vue项目打包为桌面应用-基础篇/"},{"title":"hexo + github page 搭建","text":"安装环境前提：Node + Git I. hexo安装1. 使用npm安装hexo1npm install -g hexo-cli 2. hexo初始化123hexo init folderNamecd folderNamenpm install 3. 启动服务1hexo server 浏览器输入地址：localhost:4000查看. 4. github pagegit上新建仓库, 项目名为： yourusername.github.io, 记住仓库的地址后面需要部署到这个仓库里面来. 5. 配置git根目录/_config.yml 1234567{ deploy: type: git repository: https://github.com/ctrlands/ctrlands.github.io.git branch: master message: message} 了解更多：hexo deploy 6. 更换主题选择自己喜欢的主题下载，然后将主题文件放在 根目录/themes 文件下，默认主题(landspace)可删掉.然后在 根目录/_config.yml 123{ theme: hexo-theme-icarus} 查看更多主题：hexo theme 7. 生成静态页面1hexo generate 可简写为: 1hexo g 生成的文件位于 根目录/Public 文件夹里面. 8. 部署1hexo deploy 可简写为: 1hexo d 若遇到提示：ERROR: Deployer not fonud git.执行命令安装：npm install hexo-deployer-git --save安装成功后初次提交会输入用户名和密码, 若不想每次提交输入验证, 需添加ssh key, git添加ssh key 9. 域名解析在 根目录/themes/your theme/source 根目录中添加CNAME文件,无任何后缀名，文件内容为你的域名(eg: www.ctrlands.com). Ⅱ. 域名解析绑定在域名提供商控制台页面添加域名解析记录： 记录类型选CNAME 记录值填username.github.io. Ⅲ. 其他hexo中的 根目录/_config.yml 为站点配置文件.根目录/theme/downloadTheme 中的_config.yml为主题配置文件.设置语言为中文：修改 站点配置文件 中的 language: zh-Hans,若未生效，将主题配置文件language文件中的zh-CN.yml改为zh-Hans.yml.hexo deploy时添加自定义commit信息： 1hexo d -message \"the info of commit\" 可简写为： 1hexo d -m \"the info of commit\" 新建文档并上传流程: 123hexo new 'document name'hexo generatehexo d -m 'commit message'","link":"/2019/06/13/hexo+githubPage搭建/"},{"title":"React Native环境搭建","text":"具体安装步骤参考文档本文记录一下安装过程中遇到的一些问题.根据文档, 先安装相关依赖, Node(&gt;=10.x), react-native-cli, Python(2.x), JDK(1.8), Android Studio. 目前我的电脑上只有react-native-cli和Android Studio还未安装,所以先安装这两个依赖. 安装react-native-cli1npm install -g react-native-cli 安装Android Studio安装AS时下载相关文件时需要翻墙, 我们可以曲线救国, 在chinaz这个网站里面选取一个延迟较低的ip地址(文本发布时我使用的ip为203.208.40.97), 然后C:\\Windows\\System32\\drivers\\etc路径下找到host文件,添加203.208.40.97 dl.google.com, 然后就可以正常下载相关文件了.第一次运行AS的时候会提示添加Proxy配置,我们因为修改了host,直接选择Auto就可以了.当相关依赖都正常安装完成后, 创建RN项目react-native init yourprojectname,创建成功后运行react-native run-android,在运行的时候报错： 123info Running jetifier to migrate libraries to AndroidX. You can disable it using \"--no-jetifier\" flag.error Failed to run jetifier. Run CLI with --verbose flag for more details.Error: spawnSync C:\\Users\\LJ\\Desktop\\React\\AwesomeProject\\node_modules\\jetifier\\bin\\jetify ENOENT 后来在github中project的issue中找到解决方案：react-native run-android --no-jetifier","link":"/2019/07/16/React-Native环境搭建/"},{"title":"前端编码规范-ESLint","text":"coding…","link":"/2019/06/21/前端编码规范-ESLint/"},{"title":"如何在IIS服务器上部署Asp.Net项目","text":"I. 项目发布使用工具及环境: Visual Studio 2017 + Windows Server 2008 项目解决方案右键选择”批生成“ 弹窗中”全选“后”重新生成“ 找到项目启动文件, 右键”发布“ 启动-&gt;在新弹窗中选择”IIS、FTP发布”-&gt;创建配置文件-&gt;发布方法选择”文件系统”-&gt;选择发布文件存放的位置 新界面点击”发布” I. 项目部署 Win+R, 输入mstsc远程登陆服务器, 以Windows Server 2008为例, 填写服务器地址, 用户名Administrator(默认), 密码. 服务器桌面, “我的电脑”右键”管理”-&gt;打开”服务器管理器”-&gt;”角色”-&gt;”添加角色”-&gt;下一步, 选择”Web服务器(IIS)”-&gt;下一步, 勾选”应用程序开发(Asp.Net, .NET扩展, ISAPI扩展, ISAPI筛选器), 常用HTTP功能(静态内容,默认文档,HTTP错误,HTTP重定向)”-&gt;下一步, “安装”-&gt;等待安装完成, 浏览器输入”127.0.0.1”查看是否安装成功. “开始”菜单-&gt;Internet信息服务(IIS)管理器-&gt;”网站”右键”添加网站”-&gt;填写”网站名称”, “物理路径”选择刚才发布文件的位置, 填写”端口”号(购买的服务器需要开放该端口) Ⅲ. 其他IIS中, 选择你的网站项目添加”绑定”(右侧), 端口号填写80, 填写其他端口会导致通过域名访问时的页面是iis默认的首页, 而不是项目的首页. 绑定值添加两条记录yourdomain.com, www.yourdomain.com, 这样就可以通过两种方式访问了.(如果只添加了yourdomain.com, 当你通过www.yourdomain.com访问的时候就页面就会显示404).SQL Server运行需要.Netframework和VS2015环境, SQL Server TCP端口1433可能未设置. 打开SQL Server配置管理器, SQLEXPRESS的协议-&gt;TCP/IP右键-&gt;IPALL-&gt;TCP端口1433","link":"/2019/06/17/如何在IIS服务器上部署Asp.Net项目/"},{"title":"如何搭建一个简易Node.js服务器","text":"在这个前后端分离的时代, 前台页面数据的渲染往往依托于后台, 我们不能等后台代码编写完成才来编写前台页面, 因此我们可以自己搭建一个简易的后台服务, 或者使用postman来模拟获取后台数据. 今天我们选择使用Node.js + express 来搭建一个简易的后台服务. 既然选择使用Node, 那么Node环境肯定是需要安装的, 至于如何安装Node, 这里就不做多的介绍了. 安装express命令行界面, 全局安装express: 1npm install express-generator -g 初始化项目选择项目生成文件位置, eg: D:/Express, 在此目录下进入命令行 1express projectname 等待相应文件生成后, 12cd projectnamenpm install 运行项目相关npm依赖安装完成后, 命令行输入: 1npm start 浏览器输入: localhost:3000 查看, 默认端口号可在 projectname/bin/www 文件中查看. 修改默认模板引擎express默认页面模板引擎为jade, 我不习惯这种style, 所以我选择ejs, ejs模板引擎对html的结构改动较小.或者在创建express项目的时候就指定ejs为默认模板引擎.express -v ejs projectname首先安装ejs: 1npm install ejs -save 修改projectname/app.js 123// view engine setup// app.set('view engine', 'jade');app.set('view engine', 'ejs'); 跨域配置修改projectname/app.js 123456789// 允许跨域设置var allowCrossDomain = function (req, res, next) { res.header('Access-Control-Allow-Origin', '*'); res.header('Access-Control-Allow-Methods', 'GET,PUT,POST,DELETE'); res.header('Access-Control-Allow-Headers', 'X-Requested-With,content-type'); res.header('Access-Control-Allow-Credentials', 'true'); next();};app.use(allowCrossDomain); 路由管理目前系统中的所有路由都写在了app.js里面, 随着路由的增多, app.js 也变得臃肿起来, 所以我们需要对路由进行集中管理.当我们使用Node.js + express搭建项目的时候, 前台有多个路由, 后台管理也有多个多个路由, 我们可以将其分开统一管理.首先, 我们修改 app.js 12345// 路由管理// 前台页面访问的路由 /xxxapp.use('/', require('./route/web/index.js'));// 后台管理访问的路由 /cms/xxxapp.use('/cms/', require('./route/cms/index.js')); 在route文件目录下新建”web”和”cms”两个文件夹, 分别在两个文件下新建文件”index.js” 1234567891011121314// /web/index.jsconst express = require('express');module.exports = function () { let router = express.Router(); router.get('/', (req, res) =&gt; { res.render('web/index.ejs', {}); }); router.use('/xxx', require('./xxx')()); // router.use('/route1', require('./route1')()); // router.use('/route2', require('./route2')()); // ...... more ...... return router;} 1234567891011121314// /cms/index.jsconst express = require('express');module.exports = function () { let router = express.Router(); router.get('/', (req, res) =&gt; { res.render('cms/index.ejs', {}); }); router.use('/xxx', require('./xxx')()); // router.use('/route1', require('./route1')()); // router.use('/route2', require('./route2')()); // ...... more ...... return router;} 连接Mysql首先安装mysql 1npm install mysql -save","link":"/2019/06/21/如何搭建一个简易Node-js服务器/"},{"title":"前后端项目分离-服务器端部署","text":"项目基本环境: 前端使用Vue, 后端使用SpingBoot + Maven管理, 服务器端使用Nginx代理 项目打包 后端用的Ide开发工具, 在ide右侧Maven Projects工具栏中打开maven管理, 先执行 clean, 然后执行 package, 完成打包, 打包完成的文件(一个zip包)在target文件下. Vue项目打包, 执行 npm run build 即可完成项目的打包工作, 打包后的文件在dist文件里面, 将其压缩成.zip文件备用. 注意打包前需修改 build/utils.js 文件中 publicPath: '../../ 和 config/index.js 文件中的assetsPublicPath: './', 不然打包后相关资源路径可能找不到. 服务器端Nginx安装配置 先去Nginx官网下载适合自己系统的版本, 本文以Win10为例, 下载完成后将文件解压放在 D:\\nginx-1.16.1(自由发挥) Nginx文件路径基本信息: 我们打包后的前端文件直接放在 html 这个文件夹中, conf 是Nginx的相关配置文件夹, logs 是Nginx相关日志记录文件夹, Nginx默认是80端口, 可能出现80端口被占用的情况, 我们这里选择一个最简单的方法, 不使用80端口, 修改Nginx配置文件, 在 D:\\nginx-1.16.1\\conf\\nginx.conf, 12345678910111213141516171819202122232425262728293031323334353637server { listen 81; listen [::]:81 default_server; # 代理的后端请求接口 server_name 127.0.0.1:9090; # 文件上传最大值 client_max_body_size 70M; # 页面文件夹 location / { root html; index index.html index.htm; } # 把 /api 路径下的请求转发给真正的后端服务器 location /api { # 把 /api 路径下的请求转发给真正的后端服务器 proxy_pass http://127.0.0.1:9090; # 获取用户真实IP, 把host头传过去，后端服务程序将收到your.domain.name, 否则收到的是localhost:81 proxy_set_header Host $http_host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; # 把cookie中的path部分从/api替换成/ proxy_cookie_path /api /; # 把cookie的path部分从localhost:81替换成your.domain.name proxy_cookie_domain localhost:81 http://127.0.0.1:9090; } #error_page 404 /404.html; # redirect server error pages to the static page /50x.html # error_page 500 502 503 504 /50x.html; location = /50x.html { root html; }} 启动Nginx: 直接运行 Nginx.exe 文件, 停止服务: nginx -s stop 启动运行后台 找到打包后的后台项目文件解压, 会有一个.jar文件和一个application.properties文件, 以默认配置运行 java -jar youServerFile.jar, 以自定义配置文件(application.properties)运行 java -jar -Dspring.config.location=%cd%\\application.properties -Dlogging.path=%cd%\\log %cd%\\youServerFile.jar","link":"/2019/09/29/前后端项目分离-服务器端部署/"},{"title":"浏览器Cookie过期后未被自动删除分析","text":"最近在做一个项目, 其中一个需求是用户登陆的时候可以记住密码, 有效时间内可以不用输入用户名和密码, 相关信息自动填充到输入框, 用户直接点击登陆就可以了. 我想到的第一个方法就是用cookie, 用户登陆校验成功后, 将用户的信息保存到cookie中. 可是后来发现超过设置的cookie的最大期限, cookie仍然存在浏览器中, 查询后才知道, cookie的设置时间与服务器的时间时区有关, 我们设置cookie的时候一般使用的是本地时间, 查看请求header里面可以看到data, 这个时间和本地时间不一样的, 我们设置的cookie时间是以服务器中的这个时间为准的.eg：注意图片箭头指示位置时间, 当前时间2019/8/30 15:32, 而我们生成的cookie的最大时间为2019/8/30 07:34:52这个时候已经超过了cookie的最大期限, 按理说它应该被浏览器自动清除了, 可是它还是存在, 这不恶心人吗. 我们再看下面这张图片这个是用户登陆请求的api信息, 我们可以看到箭头指示位置的时间, 本地时间是15:32, 而服务器的时间才07:32, 我设置cookie的时候, 时间设置的约2分钟, 刚好和cooke的最大时间07:34吻合,如果这样的话, 本地时间为15:34的时候, cookie就应该被浏览器自动清除了.如上图所示, 果不其然. 到了cookie的最大期限后, cookie便会被浏览器自动清除的.","link":"/2019/08/30/浏览器Cookie过期后未被自动删除分析/"}],"tags":[{"name":"CSS","slug":"CSS","link":"/tags/CSS/"},{"name":"Kendo UI","slug":"Kendo-UI","link":"/tags/Kendo-UI/"},{"name":"Cordvoa","slug":"Cordvoa","link":"/tags/Cordvoa/"},{"name":"MAML","slug":"MAML","link":"/tags/MAML/"},{"name":"Markdown Lint","slug":"Markdown-Lint","link":"/tags/Markdown-Lint/"},{"name":"Electron","slug":"Electron","link":"/tags/Electron/"},{"name":"React Native","slug":"React-Native","link":"/tags/React-Native/"},{"name":"html","slug":"html","link":"/tags/html/"},{"name":"Asp.Net","slug":"Asp-Net","link":"/tags/Asp-Net/"},{"name":"Node.js","slug":"Node-js","link":"/tags/Node-js/"},{"name":"服务器","slug":"服务器","link":"/tags/服务器/"}],"categories":[{"name":"Lint","slug":"Lint","link":"/categories/Lint/"},{"name":"Kendo UI","slug":"Kendo-UI","link":"/categories/Kendo-UI/"},{"name":"Vue","slug":"Vue","link":"/categories/Vue/"},{"name":"MIUI","slug":"MIUI","link":"/categories/MIUI/"},{"name":"hexo","slug":"hexo","link":"/categories/hexo/"},{"name":"React Native","slug":"React-Native","link":"/categories/React-Native/"},{"name":"Asp.Net","slug":"Asp-Net","link":"/categories/Asp-Net/"},{"name":"Node.js","slug":"Node-js","link":"/categories/Node-js/"},{"name":"Server","slug":"Server","link":"/categories/Server/"},{"name":"html","slug":"html","link":"/categories/html/"}]}